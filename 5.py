import numpy as np
import pandas as pd

def f(x):
    """Функция для нахождения минимума."""
    return x ** 2 + (-1) * x * 14 + 1

def find_minimum():
    # Этап 1: Инициализация
    k = 0  # Счетчик итераций
    x0 = 0  # Случайное начальное значение x0
    step = 1.0  # Определяем величину шага
    a, b = None, None  # Начальные границы отрезка

    # Поиск направления убывания
    while True:
        f_x0 = f(x0)  # Вычисляем значение функции f(x0)
        print(f"Итерация {k}: x0 = {x0}, f(x0) = {f_x0}")

        # Проверка на уменьшение
        x1 = x0 + step  # Вычисляем новую точку
        f_x1 = f(x1)  # Вычисляем значение функции в новой точке

        if f_x1 < f_x0:
            # Значение функции уменьшилось
            x0 = x1  # Двигаемся вправо
            k += 1  # Увеличиваем счетчик итераций
        else:
            # Значение функции увеличилось, меняем направление
            step = -step  # Теперь будем двигаться влево (уменьшая x)
            x1 = x0 + step  # Вычисляем новую точку
            f_x1 = f(x1)  # Вычисляем значение функции в новой точке

            if f_x1 < f_x0:
                x0 = x1  # Двигаемся влево
                k += 1  # Увеличиваем счетчик итераций
            else:
                # Если значение не уменьшилось, уменьшаем шаг
                step /= 2
                # Проверяем, если после 3 итераций значение не изменилось
                if k >= 3 and f_x1 == f_x0:
                    a, b = x0 - step, x0 + step  # Определяем отрезок
                    break  # Выходим из цикла
    print(f"Итерация {k}: x0 = {x0}, f(x0) = {f_x0}, {a}, {b}, {step}")
    # Удвоение шага
    step *= 2
    x_k_plus_1 = x0 + step  # Переходим к новой точке

    # Определение точки возрастания
    while True:
        f_x_k_plus_1 = f(x_k_plus_1)  # Вычисляем значение функции в новой точке

        if f_x_k_plus_1 < f(x0):
            x0 = x_k_plus_1  # Двигаемся вправо
            k += 1  # Увеличиваем счетчик итераций
            x_k_plus_1 = x0 + step  # Обновляем x_k_plus_1
        else:
            # Если значение функции увеличилось, определяем границы отрезка
            a, b = (x0 - step, x_k_plus_1) if x_k_plus_1 > x0 else (x_k_plus_1, x0)
            break  # Выходим из цикла

    print(f"Границы отрезка: a = {a}, b = {b}")

    # Метод деления функции пополам
    e = 0.1  # Точность
    results = []  # Список для хранения результатов итераций

    print(f"Важно___________ {a},{b},{e}")

    while (b - a) / 2 > e:  # Проверка на точность
        print("Итерация")
        # Находим середины отрезка
        x1 = (a + b - step) / 2
        x2 = (a + b + step) / 2
        f_x1 = f(x1)  # Вычисляем значение функции в x1
        f_x2 = f(x2)  # Вычисляем значение функции в x2

        # Сохраняем результаты для таблицы
        results.append([k, a, b, x1, x2, f_x1, f_x2, (b - a) / 2])

        # Сравниваем значения функции в x1 и x2 для определения нового отрезка
        if f_x1 < f_x2:
            b = x2  # Уменьшаем верхнюю границу
        else:
            a = x1  # Увеличиваем нижнюю границу

        print("Итерация")

    # Вывод результатов
    print("Результаты итераций:")
    min_x = (a + b) / 2  # Находим середину отрезка
    min_f = f(min_x)  # Вычисляем значение функции в минимальной точке

    # Конвертация результатов в DataFrame и вывод
    df = pd.DataFrame(results, columns=["k", "a", "b", "x1", "x2", "f(x1)", "f(x2)", "(b-a)/2"])
    print(df)  # Выводим таблицу результатов
    print(f"Минимум функции достигается в x = {min_x}, f(x) = {min_f}")  # Выводим найденный минимум

# Запускаем функцию поиска минимума, если скрипт выполняется напрямую
if __name__ == "__main__":
    find_minimum()