import numpy as np
import pandas as pd


def f(x):
    """Функция для нахождения минимума."""
    return x ** 2 + (-1) * x * 14 + 1


def find_minimum():
    # Этап1
    k = 0
    x0 = np.random.randint(-10, 10)  #Выбираем произвольно х^0
    f_x0 = f(x0) #находим значение функции в x0
    step = 1.0  # Определяем величину шага
    a, b = None, None

    #Находим точку, в которой значение функции будет меньше чем в f(x^0), определяем направление убывания функции
    while True:

        f_x1 = f(x0 + step) # #х ^ 0 + шаг + f(х^0 + шаг)

        if f_x1 < f_x0:
            #если  f(х^0 + шаг)< f(x^0), то полагаем x^1=x^0 + шаг и переходим к этапу 2
            x1 = x0 + step  # Вычисляем новую точку
            break
        else:
            #Если f(х^0 + шаг) > f(x^0), то полагаем шаг = - шаг
            step = -step
            x1 = x0 + step #х^0 + шаг
            f_x1 = f(x1) #f(х^0 + шаг)

            if f_x1 < f_x0:
                #если   f(х^0 + шаг)< f(x^0), то x^1=x^0 + шаг и k=k+1 и переходим к этапу два
                x1 = x0 + step  # Двигаемся влево
                k += 1
                break
            else:
                #Если f(х^0 + шаг) > f(x^0), то шаг делим на два и переходим к пункту 4а)
                step /= 2  # Уменьшаем шаг
                k += 1

            #Если после 3-Ий итерации  f(х^0 + шаг) = f(x^0), то [а, б] ==[x^0 - шаг, x^0 + шаг]
            if k >= 3 and f_x1 == f_x0:
                a, b = x0 - step, x0 + step
                break

    print(a, b)

    # Этап 2
    while True:
        step *= 2 #Удвоить шаг в два раза
        x_k_plus_1 = x0 + step #x^(k+1)=x^(k) + шаг

        # Этап 3 Определить точку в которой начинается возрастание функции
        f_x_k_plus_1 = f(x_k_plus_1) #f(x^(k+1))

        if f_x_k_plus_1 < f(x0):
            #Если f(x^k+1) < f(x^k), то полагаем k=k+1 и переходим к этапу 2
            k += 1
        else:
            #Если f(x^(k+1)) > f(x^k), то [а,б]= [x^(k-1), x^(k+1)] или [а,б]= [x^(k+1),x^(k-1)]
            a, b = (x0 - step, x_k_plus_1)
            break

    print(a,b)
    # Нахождение точки  минимума функции f(x)= x**2 + ((-1)*x*14 + 1 на отрезке [a,b] с точностью до е=0,1
    e = 0.1  # Точность
    results = []

    while (b - a) / 2 > e:  # Проверка на точность
        x1 = (a + b - step) / 2 #Находим x1=(a+b-шаг)/2
        x2 = (a + b + step) / 2 #x2=(a+b+шаг)/2
        #Находим f(x1) и f(x2)
        f_x1 = f(x1)
        f_x2 = f(x2)



        if f_x1 < f_x2:
            #Если f(x1)<f(x2)，то b=x2 и [a,b] =[a,x2]
            b = x2  # Уменьшаем верхнюю границу
            a, b = a, x2
        elif f_x1 > f_x2:
            # Если f(x1)>f(x2)，то a=x1 и [a,b] =[x1,b]
            a = x1
            a, b = x1, b
        else:
            #Если f(x1)=f(x2), то [a,b]=[a,x2] или [a,b]=[x1,b]
            a, b = a, x2


        # Сохранение результатов для таблицы
        results.append([k, a, b, x1, x2, f_x1, f_x2, (b - a) / 2])


    # Вывод результатов
    min_x = (a + b) / 2
    min_f = f(min_x)

    # Конвертация результатов в DataFrame и вывод
    df = pd.DataFrame(results, columns=["k", "a", "b", "x1", "x2", "f(x1)", "f(x2)", "(b-a)/2"])
    print(df)
    print(f"Минимум функции достигается в x = {min_x}, f(x) = {min_f}")


if __name__ == "__main__":
    find_minimum()